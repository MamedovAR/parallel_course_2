/*
OpenACC

Ну что там с UTF-8? Работает?
Ладно.

OpenACC - прикладной программный интерфейс, переводящий выборку дериктив компилятора в специальные массивы и блоки кода стандарта C/C++ и Fortran, чтобы параллельно иполнять на нескольких ядрах CPU или выгружать и исполнять параллельно на подключённом ускоряющем устройстве, обеспечивая портируемость в обход операционных систем, процессоров и ускорителей.
Многие директивы OpenACC применяются сразу после структурного блока или цикла; структурный блок - либо одна операция, либо объединение операций (C/C++), либо последовательность операций (Fortran) с единственной точкой входа в начале и единственным выходом в конце.

Основной синтаксис

C/C++: 
#pragma acc директива [выражение [[,] выражение]...] следующая строка
Fortran:
!$acc директива [выражение [[,] выражение]...]

Конструкция OpenACC представляет собой директиву OpenACC и, если применимо, слудующую операцию, цикл или структурный блок.

Вычислительные конструкции: 
parallel, kernels, serial.

Конструкция parallel
Конструкция parallel параллельно запускает некоторое количество (потоков? переводится как банды, что вполне логично, с учётом того, как называется следующая абстракция; в оригинале - gangs), где в каждой банде (пускай будет так) может поддерживать множество (опять же - потоков? рработников? воригинале - workers), каждый с вектором или операциями SIMD (переводится как: одна инструкция, множество данных, ну или типа того).

C/C++
-----------------------------------------------------
#pragma acc parallel [выражение [[,] выражение]...] следующая строка
{структурный блок}
-----------------------------------------------------

Fortran
-----------------------------------------------------
!$acc parallel [выражение [[,] выражение]...]
{структурный блок}
!$acc end parallel
-----------------------------------------------------

Выражения
if(условие)
self[(условие)]
default(none)
default(present)
device_type или dtype([*|device-type-list])
async[(выражение)]
wait[(список выражений)]
num_gangs(выражение)
num_workers(выражение)
vector_length(выражение)
reduction(операттор: список)
private(список)
firstprivate(список)
Смотреть выражения вычислительных конструкций

copy(список)
copyin([readonly:] список)
copyout(список)
create(список)
no_create(список)
present(список)
deviceptr(список)
attach(лист)
Смотреть выражения для данных; выражения для данных для конструкции kernels изменияют структурированный счётчик ссылок для ассоциативных данных, как бы криво это не переводилось.

Конструкция serial (странно, что раньше я её не замечал; вероятно из-за того, что здесь код исполяется последовательно, что не очень интересно)
Конструкция serial окружает циклы или куски кода, чтобы они исполнлись на устройстве последовательно.

C/C++
----------------------------------------
#pragma acc serial [выражение [[,] выражение] ...] следующая строка
{структурный блок}
----------------------------------------

Fortran
----------------------------------------
!$acc serial [выражение [[,] выражение] ...]
{структурный блок}
!$acc end serial
----------------------------------------

Выражения
if(условие)
self[(условие)]
default(none)
default(present)
device_type или dtype([*|device-type-list])
async[(выражение)]
wait[(список выражений)]
reduction(операттор: список)
private(список)
firstprivate(список)
Смотреть выражения вычислительных конструкций

copy(список)
copyin([readonly:] список)
copyout(список)
create(список)
no_create(список)
present(список)
deviceptr(список)
attach(лист)
Смотреть выражения для данных; выражения для данных для конструкции serial изменияют структурированный счётчик ссылок для ассоциативных данных, как бы криво это не переводилось.

Выражения вычислительных конструкций
if(условие)
Когда условие ненулевое или истинное, вычисление сей области будет проводится на устройстве; иначе, локальный поток будет исполняться регионально.
self[(условие)]
Когда условие не действует или когда условие ненулевое или истинное, вычисление области будет выполняться на локальном устройстве; иначе вычисление области будет выполняться на текущем устройстве.
default(none)
Неявно запрещает компилятору разделять атрибуты данных для любых преременных, используемых или объявленных в конструкции.
default(present)
Неявно предполагает, что нескалярные данные отсутствуют в текужем выражении (Я сильно изменил это предложение).
device_type или dtype([*|device-type-list])
Может сопровождаться любым выражением из представленных ниже. Выражения, следующие за device_type будут применяться только когда компилируютсядля обозначенного типа (типов) устройств. Выражения, следующие за device_type(*), применяются ко всем устройствам, не названным в прочих выражениях device_type. Может появиться больше, чем единожды с различными типами устройств.
async[(выражение)]
Вычисление области выполняется асинхронно на локальных потоках в соответствующей асинхронной очереди. Без аргументов исполнение области будет происходить в асинхронной очереди по умолчанию.
async [(Выражение)]
Блок кода исполняется асинхронно на локалбном потоке в соответствующей асинхронной очереди.
wait[(список выражений)] - или список выражений
Блок кода не будет выполнятся до тех пор, пока все задачи из текущей асинхронной очереди (очередей) не завершатся. По умолчанию ожидание продлится до тех пор, пока не завершатся все задачи во всех очередях.
num_gangs(выражение)
Контролирует число созданных банд.
num_workers(выражение)
Контролирует число созданных работников (я знаю, звучит странно) в каждой банде. Да уж. А давайте далее по тексту банда = бригада. 
Контролирует число запущенных работников в каждой бригаде. Пожалуй, так будет лучше.
vector_length(выражение)
Контролирует длину вектора для каждого работника.
reduction(оператор: список)
Приватное копирование длчя каждой переменной, массива или области массива в списке аллоцируется для каждой бригады. Значения для всех банд комбинируется с оператором в конце каждого распараллеленной области. Редукции массива выполнены индивидуально для каждого элемента. Редукция композиции переменных выполняется индивидуально для каждого члена. Операторы для C/C++: +,*,max,min,&,|,^,&&,||; Для Fortran: +, *, max, min, iand, ior, ieor, .and., .or., .eqv., .neqv. Внешность переменных в выражении reduction подразумевает выражение copy для квждой переменной.
private(список)
Копия каждой переменной в списке аллоцируется для каждой бригады.
firstprivate(список)
Копия каждой переменной в списке аллоцируется для каждой бригады и инициализуется со значением переменной локального потока.

Конструкция data
Конструкция data определяет область программы, в которой данные понятны устройству.

C/C++
----------------------------------------
#pragma acc data [выражение [[,] выражение]] следующая строка
{структурный блок}
----------------------------------------

Fortran
----------------------------------------
!$acc data [выражение [[,] выражение]]
структурный блок
!$acc end data
----------------------------------------

Выражения
if (условие)
Когда условие нулевое или ложно, копирования данных туда-сюда не происходит.
copy(список)
copyin([readonly:] список)
copyout(список)
create(список)
no_create(список)

        -----------+-----------
              _____|____
             /  __      \
          __[] |[]|[] [] \__________/|              Решил развлечься, вертолёт нарисовал в ASCII.
         /     |~ |      ,----------\|
         \______________/
           O O         O

present(список)
deviceptr(список)
attach(список)
default(none)
default(present)

Смотреть выражения для данных; выражения для данных в конструкции data изменяет структурированный счётчик ссылок для ассоциативных данных. Выражение default подразумевает, что выражение default в любой вычисляемой конструкции закрывается вместе с директивой data; смотреть вычисляемые выражения конструкции?

Директива enter data

C/C++
--------------------------------------
#pragma acc enter data [выражение [[,] выражение]...] следующая строка
--------------------------------------

Fortran
--------------------------------------
!$acc enter data [выражение [[,] выражение] ...]
--------------------------------------
:(
 ____________ 
< I am tired >
 ------------ 
        \   ^__^
         \  (--)\_______
            (__)\       )\/\
                ||----w |
                ||     ||

Спасибо, cowsay, за визуализацию.

Выражения
if(условие)
Когда условие нулевое или ложное, никаие данные не будут аллоцируемы или перемещены на усройство.
async[(выражение)]
Перемещение данных выполняется с локального потока в соответствующую фсинхронную очередь. По умолчанию копирование производится в очередь по умолчанию.
wait[(список выражений, вероятно)]
Перемещение данных не производится, пока все действи в соостветствующей очереди не завершаться. По умолчанию ожидается завершение всех действий во всех очередях.
copin(список)
create(список)
attach(список)
Смотреть выражения для данных; выражения для данных после директивы enter data изменяет число динамических ссылок для ассоциативных данных.

Директива exit data

_________________________________________ 
/ the exit data directive kill enter data \
\ directive                               /
 ----------------------------------------- 
      \                    / \  //\
       \    |\___/|      /   \//  \\
            /0  0  \__  /    //  | \ \    
           /     /  \/_/    //   |  \  \  
           @_^_@'/   \/_   //    |   \   \ 
           //_^_/     \/_ //     |    \    \
        ( //) |        \///      |     \     \
      ( / /) _|_ /   )  //       |      \     _\
    ( // /) '/,_ _ _/  ( ; -.    |    _ _\.-~        .-~~~^-.
  (( / / )) ,-{        _      `-.|.-~-.           .~         `.
 (( // / ))  '/\      /                 ~-. _ .-~      .-~^-.  \
 (( /// ))      `.   {            }                   /      \  \
  (( / ))     .----~-.\        \-'                 .~         \  `. \^-.
enter data   ///.----..>        \             _ -~             `.  ^-`  ^-_
               ///-._ _ _ _ _ _ _}^ - - - - ~                     ~-- ,.-~
                                                                  /.-~

Довольно хорошо иллюстрирует то, что делает exit data.

Данные, перенесённые на устройство с помощью директивы enter data, будут перенесены обратно, память на устройстве будет дефллоцирована.

C/C++
------------------------------------------
#pragma acc exit data [выражение [[,] выражение]] следующая строка
------------------------------------------

Fortran
------------------------------------------
!$acc exit data [выражение [[,] выражение]]
------------------------------------------

Выражения
if (условие)
Если условие нулевое или ложно, данные не будут перенесены в асинхронную очередь или деаллоцированы.
async[(выражение)]
Перенос данных выполняется асинхронно с текущего потока в соответствующую асинхронную очередь.
wait[(список выражений)]
Перенос данных не будет совершон до тех пор, пока действия в текущей асинхронной очереди (очередях) не завершатся.
finalize
Зануляет число динамических ссылок.
copyout(список)
delete(список)
detach(список)
Смотреть выражения для данных; выражения для данных после директивы exit data изменяет число динамических ссылок для ассоциативных данных.

Выражения для данных
Описание применимо к выражениям, используемых в вычислительных конструкциях, конструкциях data и директивах enter data и exit data. Выражентия для данных не обязательно следуют после выражения device_type. Эти выражения не влияют на данные в общей памяти.

copy(список) parallel, kernels, serial, data, declare
При заходе в область программы, если данные в списке уже готовы на текущем устройстве, структурированное число ссылок инкркементкируется и осуществлчется копирование данных. Иначе данные аллоцируется в памяти устройства и копируются значения из локальной памяти и приравнивает число структурированных ссылок к единице. При выходе из области программы число структурированных ссылок декременируется. Если оба числа структурированных ссылок равны нулю, данные копируются из памяти устройства в локальную память, а память устройства деаллоцируется.
copyin([readonly:] список) parallel, kernels, serial, data, declare
При заходе в область программы или при директиве enter data, если данные в списке уже готовы в памяти текущего устройства, применяемое число ссылок инкрементируется и производится копирование. Иначе память устройства аллоцируется,  значения из локальной памяти копируются и применяемое число ссылок приравнивается к единице. При выходе из области программы число структурированных ссылок декременируется. Если оба числа ссылок равны нулю. память устройства деаллоцируется. Если применеяется модификатор readonly, данные не должны быть записаны внутри сей области.
copyout(список) parallel, kernels, serial, data, declare
При заходе в область кода, если данные в списке уже готовы в в памяти текущего устройства, число структурированных ссылок инкрементируется и происходит копирование. Иначе память устройства аллоцируется и число структурированных ссылок приравнивается к единице. При директиве exit data без выражения finalize или при выходе из области кода применяемое число ссылок декременируется. При директиве exit data с выражением finalize динамическое число ссылок зануляется. В ином случае оба числа ссылок зануляются, данные копируются из памяти устройства в локальную память и память устройства деаллоцируется.
create(список) parallel, kernels, serial, data, declare
При попадании в область кода или при директиве enter data, если данные в списке уже готовы в памти текущего устройства, то применяемое число ссылок инкрементируется и производится копирование. Иначе память устройства аллоцируется и число структурированных ссылок приравнивается к единице. При выходе из области программы число структурированных ссылок декременируется. В ином случае оба числа ссылок зануляются, данные копируются из памяти устройства в локальную память и память устройства деаллоцируется.
no_create(список) parallel, kernels, serial, data
При заходе в область кода, если данные в списке уже готовы в в памяти текущего устройства, число структурированных ссылок инкрементируется и происходит копирование. Иначе никиких действи не производится и любой код на устройстве в конструкции будет использовать адресс локальной памяти для данных?
delete(список) exit data
Без выражения finalize число динамических ссылок декрементируется. С выражением finalize число динамических ссылок зануляется. В любои случае, если оба числа ссылок нулевые, память устройства деаллоцируется.
present(список) parallel, kernels, serial, data, declare
При заходе в область кода данные должны уже быть представлены в памяти устройства, а число структурированных ссылок должно быть инкрементировано. При покидании области кода число структурированных ссылок должно юыть декрементировано.
deviceptr(список) parallel, kernels, serial, data, declare
C/C++: список должен содержать в себе указатели на переменные, содержащиеся адреса устройства, в том числе полученные из acc_malloc. Fortran: список должен содержать макеты аргументов и не должен содержать ссылок, аллокаторов, или значения атрибутов..
attach(список) parallel, kernels, serial, data, enter data
При входе в область кода или при директиве enter data, если указатели в списке уже прикреплены к своим целям, число прикреплений инкрементируется. Иначе указатели на устройстве прикрепляются к их целям на устройстве и число прикреплений приравнивается к единице. При выходе из области кода число прикреплений декременируется, если число достигает нуля, указатели отделяются. (Я не понял, как это перевести: pointers, attachmen, reaches...)
detach(список) exit data
Без выражения finalize число прикреплений для указателей в списке декременируется. С выражением finalize число прикреплений для указателей приравнивается к нулю. В любом случае, если число прикреплений приравнивается к нулю, указатели в списке будут откреплены.

Конструкция host_data
По-хорошему мне не стоило переводить слово device. Слово host я буду переводить как хост.
Конструкция host_data делает адреса данных на устройстве доступными на хосте.
C/C++
--------------------------------------
#pragma acc host_data [выражение [[,] выражение]] следующая строка
{структурный блок}
--------------------------------------

Fortran
--------------------------------------
!$acc host_data [выражение [[,] выражение]]
структурный блок
!$acc end host_data
--------------------------------------

Выражения

use_device(список)
Направляет компилятор исполозовать адреса устройства при любых входных в списке, к примеру, когда процедуре передаются переменные.
if(условие)
Когда условие нулевое или ложно, память устройства не используется.
if_present
Если любые входные в списке не представлены в памяти текущего устройства, адресс устройства не будет использован и ошибки не произойдёт.

Конструкция loop
Конструкция loop сразу же после цикла или к плотно вложенным цикллам и описывает тип параллелизма устройств для использования для исполнения итераций цикла. (Коряво, знаю).
C/C++
--------------------------------------
#pragma acc loop [выражение [[,] выражение]] следующая строка
--------------------------------------

Fortran
--------------------------------------
!$acc loop [выражение [[,] выражение]]
--------------------------------------

Выражения
collapse(n)
Применяет ассоциативную директиву к следующим плотно вложенным циклам.
seq
Исполняет цикл или секвенцию циклов.
auto
Инструктирует компилятор анализировать цикл или циклы определять, может ли он (могут ли они) исполняться параллельно, и по возможности, применять параллелизм банд, работников или векторов.
independent
Определяет, какие итерации цикла независимы от данных и могут исполняться параллельно, переопределяя анализ зависимостей компилятора.
tile(выражение-список)
С n выражениями определяет, что следующие n плотно вложенных цикла должны сложиться в n блоков циклов и n внутренних элемента цикла, где числа проходов по элементам цикла взято из выражения.
Первый проход применяется к самым вложенным элементам цикла.
Может комбинироваться с одним или двумя выражениями банд, работников и векторов.
device_type или dtype([* | device-type-list])
Может сопровождаться выражениями gang, vector, seq, auto, tile, colaps. Выражения, сопровождаемые device_type, будут применены только при компиляции для данного типа устройств.
private(список)
Копирование каждой переменной в списке для каждого потока, который исполняет цикл или циклы.
reduction(оператор:список)
Приватное копирование каждой переменной, массива или части массива в списке аллоцируется для каждого потока, который исполняет цикл или циклы. Значения для всех потоков комбинируются с оператором в конце цикла. Редукция массива применяется индивидуально для каждого элемента. Редукция для составных элементов применяется для каждого члена. Смотреть выражение reduction в выражениях конструкции compute для действительных операторов.

Выражение loop внутри конструкции parallel или одинокой директивы loop
gang
Доли итераций цикла или циклов через банды параллельной области.
worker
Доли итераций цикла или циклов через рабочих бригады.
vector
Доли итераций цикла или циклов через вектора или SIMD уровня.

Выражение loop внутри конструкции kernels
gang [(num_gangs)]
Исполняет итерации цикла или циклов параллельно через число бригад, большее, чем num_gangs. 
worker [(num_workers)]
Исполняет итерации цикла или циклов параллельно через число рабочих, большее, чем num_workers для одной бригады. 
vector [(vector_length)]
Исполняет итерации цикла или циклов в SIMD или vector mode, с максимумом vector_length.

Директива cache
Директива cache может добавляться к верху раздельного цикла. Элементы или части массива в списке кешируются в программно-обеспеченном кеше данных.

С,С++
-------------------------------------
#pragma acc cache(список) следующая строка
-------------------------------------

Fortran
-------------------------------------
!$acc cache(список)

 _________ 
< A-a-a-a >
 --------- 
   \
    \              ....       
           ........    .      
          .            .      
         .             .      
.........              .......
..............................

Elephant inside ASCII snake

Директива atomic
Конструкция atomic гарантирует, что специффичная локальная загрузка принимаема или обновлена атомарно, одновременно, проверена на конфликты и записана в потоки.

C/C++
------------------------------------------
#pragma acc atomic [ read | write | update | capture ] следующая строка
atomic-block
------------------------------------------
Если нет специальных выражений, выражение обновления вымышленно.
Атомарный блок должен быть примерно таким:
clause atomic-block
read v = x;
write x = expr;
update update-expr;
capture v = update-expr;
 { update-expr; v = x; }
 { v = x; update-expr; }
 { v = x; x = expr; }
где update-expr один из
x++; x--; ++x; --x;
x binop= expr;
x = x binop expr;
x = expr binop x;

FORTRAN
------------------------------------------
!$acc atomic [ read | write | update | capture ]
stmt-1
[stmt-2]
[ !$acc end atomic ]
------------------------------------------
Если нет специальных выражений, выражение обновления вымышленно. Конец директивы atomic обязателен, если stmt-2 задействован? Возможные состояния:
clause stmt-1 stmt-2
read capture-stmt
write write-stmt
update update-stmt
capture update-stmt capture-stmt
 capture-stmt update-stmt
 capture-stmt write-stmt
capture-stmt это
v = x
write-stmt это
x = expr
update-stmt один из
x = x operator expr
x = expr operator x
x = intrinsic_proc( x, expr-list )
x = intrinsic_proc( expr-list, x )

Директива update
Директива update произврдит обмен данными между памятью локального потока и устройства. Директива update может содержаться в области данных, включая подразумеваемую область. 

C/C++:
------------------------------------------
#pragma acc update [clause [[,] clause]…] следующая строка
------------------------------------------

FORTRAN
------------------------------------------
!$acc update [clause [[,] clause]…]
------------------------------------------

Выражения
self( список ) или host( список )
Копирует данные в списке из устройства в локальный поток.
device( список )
Копирует данные в списке из локального потока в устройство.
if( условие )
Когда условие нулевое или ложное, перемежения данных не будет осуществляться.
if_present
Выпуск без ошибки, когда данные не представлены в памяти устройства.
async [( выражение )]
Перемещение данных будет исполняться асинхронно из локального потока в соответствующую асинхронную очередь.
wait [( список выражений )]
Перемещение данных не начнёт исполняться до тех пор, пока все действия в текущей асинхронной очереди не завершаться.

Директива wait

Директива wait заставляет локальные потоки ждать завершения асинхронной активности на устройстве или асинхронной активации в асинхронной же очереди для синхронизации с одной или более асинхронными очередями. Без выражения ожидает для всех выдающихся асинхронных областей или перемещений данных.

C/C++
------------------------------------------
#pragma acc wait [( список выражений )] [выражение [[,] выражение]…]
следующая строка
------------------------------------------

FORTRAN
------------------------------------------
!$acc wait [( список выражений )] [выражение [[,] выражение]…]
------------------------------------------

Выражение
async [( выражение )]
Постановка в ассоциативную очередь устройства оператора wait. Локальный поток может продолжаться без ожидания.

Директива routine    (пускай будет обыденностью)
Директива routine сообжает компилятору, чтобы тот скомпилировал процедуру для устройства и подал контекст исполнения для вызовов процедуры. Такая процедура называется обыденностью устройства.

C/C++:
------------------------------------------
#pragma acc routine [выражение [[,] выражение]…] следующая строка
#pragma acc routine( имя ) [выражение [[,] выражение]…]
следующая строка
------------------------------------------

Без имени директива routine должна следовать сразу после определения функции или прототипа.

FORTRAN
------------------------------------------
!$acc routine [выражение [[,] выражение]…]
!$acc routine( имя ) [выражение [[,] выражение]…]
------------------------------------------

Без имени директива routine должна появляться в специфицированной части подобыденности (?) или функции, или в теле интерфейса подобыденности или функции в блоке интерфейса.

Выражения
gang
Указывает, что процедура должна содержать бригадо-подобный цикл, следовательно, вызовы этой процедуры должны содержать снаружи любой цикл общего назначения. Все бригады должны вызывать процедуру.
worker
Указывает, процедура может содержать работнико-подобный цикл (а как ещё перевести worker-shared), следовательно, вызовы этой процедуры должны быть вне любого работнико-подобного цикла.
vector
Указывает, что процедура может содержать векторно-подобный цикл, следовательно, вызовы сей процедуры должны быть вне любого векторно-подобного цикла.
seq
Указывает, процедура может содержать работо-подобный цикл. Вызов процедуры будет исполняться последовательно на потоке, сделавшем вызов.
bind( имя )
Указывает имя альтернвтивной процедуры при компиляции или вызове процедуры на устройстве.
bind( строка )
Указывает цитируемею строку в кчестве имени при компиляции или вызове процедуры на устройстве.
device_type или dtype( [ * | устройство-подобный список ] )
Смотреть секцию выражений вычислительных крнструкций для списка применяемых выражений. Выражения следующих device_type будут применены тольк когда компилируются для полученного типа устройств. Выражения после device_type( * ) применяются ко всем устройствам, не названным в выражении device_type.
nohost
Определяет, для какой версии хоста процедура не должна быть скомпилирована.

Глобальные данные
C/C++ глобальные переменные, статические библиотеки или внешние объекты, и модули Fortran или общие блоки переменных или массивы, используемые обыденностью устройства, должны  должны появляться в объявлении директивы при создании copyin, device_resident или выражении link.

Неявная область данных
Неявная область данных создаётся в начале каждой процедуры и в конце после после последнего заявления в процедуре.

Директива declare
Директива declare используется для указания, какие данные должны аллоцироваться в памяти устройства для продолжительности неявной области данных в программе или подпрограмме.

C/C++
------------------------------------------
#pragma acc declare [выражение [[,] выражение]…] следующая строка
------------------------------------------
FORTRAN
------------------------------------------
!$acc declare [выражение [[,] выражение]…]
------------------------------------------
Выражения данных разрешены.

Прочие выражения
device_resident( список )
Определяет, какие переменные в списке аллоцированны на устройстве для продолжительности неявной области данных.
link( список )
Для огромного глобального статическо объекта данных, специфицированном для каждого объекта в списке, ствтично аллоцированном на устройстве. Память устройства для объекта будет аллоцирована, когда объект появляется в выражении для данных и глобальная ссылка будет назначена.

Runtime Library Routines (Я не буду переводить это название)
Прототипы или интерфейсы для runtime library routines, с типами данных и перечислительными типами, доступны следующие:

C/C++
------------------------------------------
#include “openacc.h”
------------------------------------------
FORTRAN
------------------------------------------
use openacc
------------------------------------------

C AND FORTRAN ROUTINES
В дальнейшем, h_void* это void* указатель на память хоста и d_void* это void* указатель на память устройства.
acc_get_num_devices( тип устройства )
Возвращает число устройств конкретного типа.
acc_set_device_type( тип устройства )
Назначает тип устройства для использования этого потока.
acc_get_device_type()
Возвращает тип устройстйства, которое используется на этом потоке хоста.
acc_set_device_num( номер устройства, тип устройства )
Назначает номер устройства для использования на этом потоке хоста.
acc_get_device_num( тип устройства )
Возвращает номер устройства, которое используется на этом потоке хоста.
acc_get_property( номер устройства, тип устройства, принадлежность )
Возвращает целочисленную принадлежность:
acc_property_memory
acc_property_free_memory
acc_get_property_string( номер устройства, тип устройства, принадлежность )
Возвращает C стоко-значную принадлежность.
acc_get_property_string( номер стройства, тип устройства, принадлежнсть, возвращаемое значение )
Возвращает FORTRAN строко-значную принадлежность в последнем аргументе:
acc_property_name
acc_property_vendor
acc_property_driver
acc_shutdown( тип устройства )
Отключает это поток хоста от устройства.
acc_async_test( выражение )
Возвращает не ноль или истину, если все асинхронные задачи в асинхронной очереди ассоциируются с получаемыми выражениями были завершены; иначе возвращается ноль или ложь. (Тут стоит добавить, что на Fortran истинаа и ложь обозначаются ка .TRUE. и .FALSE., и вообще во всйм тексте по-хорошему стоит заменить слова истина и ложь на .TRUE. и .FALSE., но я этим заниматься не буду.)
acc_async_test_all()
Возвращает не ноль или истину, если все асинхронные задачи завершены; иначе возвращает ноль или ложь.
acc_wait( выражение )
Ожидает, пока все асинхронные задачи в асинхронной очереди ассоциируются с получаемыми выражениями не были завершены.
acc_wait_all()
Ожидает, пока все задачи в асинхронной очереди не завершатся.
acc_wait_async( выражение, выражение )
Запрашивает ожидание оператора для асинхронной очереди, ассоциированной с первым аргументом в ассоциированной асинхронной очереди со вторым аргументом.
acc_wait_all_async( выражение )
Запрашивает ожидание оператора для всей асинхронной очереди в ассоциированной с выражением асинхронной очереди.
acc_get_default_async()
Возвращает использование асинхронной очереди по умолчанию, когда не очередь специфицирована на асинхронном выражении.
acc_set_default_async( выражение )
Назначает асинхронную очередь, ассоциированную с выражением, как асинхронную очередь по умолчанию, когла не очередь специфицируется на асинхронном выражении. (Я сильно сомневаюсь в правильности всего моего перевода, не говоря уже об этой строчке).
acc_on_device( тип устройства )
В области вычислений используется, чтобы дать различные исполненяемые пути зависимости в независимости от того, где запущена программа.
acc_malloc( size_t )
Возвращает адресс памяти, аллоцированной на устройстве.
acc_free( d_void* )
Освобождает память.
acc_map_data( h_void*, d_void*, size_t )
Создаёт новое время жизни данных по адресу в памяти хоста, использует данные устройства в адресе устройства, с размером данныз в байтах.
acc_unmap_data( h_void* )
Не применение времени жизни данных перед созданием для адреса хоста по acc_map_data.
acc_deviceptr( h_void* )
Возвращает указатель на устройство, ассоциативный с адресом хоста. Возвращает NULL, если адресс хоста не представлен в памяти текущего устройства.
acc_hostptr( d_void* )
Возвращает укфзатель на хост, ассоциированный с адресом устройства. Возвращает ноль, если адресс устройства не ассоциирован с адресом хоста.
acc_memcpy_to_device( d_void*, h_void*, size_t )
acc_memcpy_to_device_async( d_void*, h_void*, size_t, int )
Копируют данные из локального потока на устройство.
acc_memcpy_from_device( h_void*, d_void*, size_t )
acc_memcpy_from_device_async( h_void*, d_void*, size_t, int )
Копируют данные из памяти устройства в локальный поток.
acc_memcpy_device( d_void*, d_void*, size_t )
acc_memcpy_device_async( d_void*, d_void*, size_t, int )
Копируют данные из памяти устройства в другое место.

Обыденность перемещения данных (Это ужасный перевод, тысяча извинений. Хотя сомневаюсь, что кто-то это читает. Я вот например вряд ли буду перечитывать это место).
Следующие data routines вызываются с C прототипами:
routine( h_void*, size_t )
и в Fortran с интерфейсом:
subroutine routine( a )
 type(*), dimension(..) :: a
subroutine routine( a, len )
 type(*) :: a
 integer :: len
Асинхронная версия вызывается с прототипами в C:
routine_async( h_void*, size_t, int )
и в Fortran с интерфейсом:
subroutine routine_async( a, async )
 type(*), dimension(..) :: a
 integer :: async
subroutine routine( a, len, async )
 type(*) :: a
 integer :: len, async
acc_copyin, acc_copyin_async
Действие сие подобно директиве enter data с выражением copyin. Тестируются, если данные представлены и если память не аллоцирована и скопированы данные текущего устройства. Инкрементируется число динамических ссылок.
acc_create, acc_create_async
Действие сие подобно директиве enter data с выражением create. Тестируются, если данные представлены и если память не аллоцирована на текущем устройстве. Инкрементируется число динамических ссылок.
acc_copyout, acc_copyout_async
Действие сие подобно директиве exit data с выражением copyout и выражением no finalize. Декрементируется число динамических ссылок. Если оба числа ссылок нулевые, данные копируются и деаллоцируется память на текущем устройстве.
acc_copyout_finalize,
acc_copyout_finalize_async
Действие сие подобно директиве exit data с выражением copyout и выражением finalize. Зануляется число динамических ссылок. Если оба числа ссылок нулевые, данные копируются и деаллоцируется память на текущем устройстве.
acc_delete, acc_delete_async
Действие сие подобно директиве exit data с выражением delete и выражением no finalize. Декрементируется число динамических ссылок. Если оба числа ссылок нулевые, деаллоцируется память на текущем устройстве.
acc_delete_finalize, acc_delete_finalize_async
Действие сие подобно директиве exit data с выражением delete и выражением finalize. Зануляется число динамических ссылок. Если оба числа ссылок нулевые, деаллоцируется память на текущем устройстве.
acc_update_device, acc_update_device_async
Действие сие подобно директиве update с выражением device. Обновление памяти устройства из соответствующей памяти хоста.
acc_update_self, acc_update_self_async
Действие сие подобно директиве update с выражением self. Обновление памяти хоста из соответствующей памяти устройства.
acc_is_present
Проверяет, доступны ли указанные данные хоста с текущего устройства. Возвращает не ноль или .TRUE. если данные в общей памяти или полностью представлены в памяти текущего устройства.
acc_attach( h_void** ), acc_attach_async( h_void**, int )
Прикрепляет к устройству копию уквзателя на аргумент цели эого устройства, если не прикреплено; иначе инкрементирует число прикреплений.
acc_detach( h_void** ), acc_detach_async( h_void**, int )
Декрементирует число прикреплений указателя  на аргумент; отделяет копию устройства от указателя на аргумент из цели этого устройства, если число достигает нуля.
acc_detach_finalize( h_void** ), acc_detach_finalize_async( h_void**, int )
Приравнивает к нулю число прикреплений указателей на аргумент и отделяет копию указателей на аргумент в устройстве из целевого устройства (на этот раз переведу так).

Переменные среды

ACC_DEVICE_TYPE устройство
Переменная специруется на типе подключаемого устройства. Может быть переписана с вызовом acc_set_device_type.
ACC_DEVICE_NUM номер
Переменная специруется на номере подключаемого устройства. Может быть переписана с вызовом acc_set_device_num.

Условия компиляции
Макрос пепроцессора _OPENACC определён со значением yyyymm, когда скомпилирован с включёнными директивами OpenACC. Описанная здесь версия имеет значение 201811.

Примечания переводчика.

Я знаю, что перевод плохой, не даром я учусь в тридцать третьей группе (самый низкий уровень английского языка), при этом 99.9% текста переведено в ручную. Здесь полно ошибок и опечаток и я не планирую их исправлять.

 _____ _   _ _____   _____ _   _ ____  _ 
|_   _| | | | ____| | ____| \ | |  _ \| |
  | | | |_| |  _|   |  _| |  \| | | | | |
  | | |  _  | |___  | |___| |\  | |_| |_|
  |_| |_| |_|_____| |_____|_| \_|____/(_)
                                         
Надпись выполнена утилитой figlet.
*/
#include <stdio.h>
#include <math.h>
#include <openacc.h>
#include <stdlib.h>
#include <nvToolsExt.h>
#define IDX2F(i,j,ld) (((j)-1)*(ld))+((i)-1)
#define IDX2C(i,j,ld) (((j)*(ld))+(i))

/*float max(float a, float b)
{
	if(a>b)
		return a;
	else 
		return b;
}*/

int main(int argc, char** argv)
{
	float a=0;
	int s=0;
	int n=0;
	if(argv[1][1]=='h')
	{
		printf("Put -h to show this.\n");
		printf("Put -a <NUMBER_OF_ACCURACY*10^6> -s <SIZE^2> -n <NUMBER_OF_ITERATION*10^6>.\n");
	}
	else
	{
		for(int k=1; k<argc; k+=2)
		{
			if(argv[k][1]=='a')
				a=(float)atof(argv[k+1]);
			else if(argv[k][1]=='s')
				s=atoi(argv[k+1]);
			else if(argv[k][1]=='n')
				n=atoi(argv[k+1]);
		}
		float* setka = (float*)calloc(s*s,sizeof(float));
		float* arr = (float*)calloc(s*s,sizeof(float));
		setka[0]=10;
		setka[s-1]=20;
		setka[(s-1)*s]=20;
		setka[s*s-1]=30;
		float l1=(10);
		l1/=s;
		float l2=20;
		l2/=s;
		int iter=0;
		float err=1;
		for(int i=1; i<s-1; i++)
		{
			setka[i]=setka[i-1]+l1;
			setka[i*s]+=setka[(i-1)*s]+l2;
			setka[s-1+i*s]+=setka[s-1+(i-1)*s]+l1;
			setka[s*(s-1)+i]+=setka[s*(s-1)+i-1]+l1;
			arr[i]=setka[i];
			arr[i*s]=setka[i*s];
			arr[s-1+i*s]=setka[s-1+i*s];
			arr[s*(s-1)+i]=setka[s*(s-1)+i];
		}
		if(s<16)
		{
			for(int i=0; i<s; i++)
			{
				for(int j=0; j<s; j++)
					printf("%f ",setka[i+s*j]);
				printf("\n");
			
			}
		}
//�������� ���� ���������, ����������� ������ � CPU �� GPU
#pragma acc data copy(setka[0:s*s],arr[0:s*s]) copyin(err,iter)
{
// copy(s,iter,err,a,n)
//		printf("%d %d %f %f %d\n",s,iter,err,a,n);
//		#pragma acc parallel loop
		while(err>a && iter<n)
		{
//���������� ������, ������������� ���������� ��������. �������� ���������� �� GPU  � ����������� �� CPU
//#pragma acc kernels
//#pragma acc update host(err,iter)
//			{
			iter++;
//			if(iter%100==0)
#pragma acc kernels
{
				err=0;
}
/*			if(iter==1)
			{
				float* dop;
				dop = arr;
				arr=setka;
				setka = dop;
			}*/
//#pragma acc update device(err)
//#pragma acc update host(err)
//			}
//#pragma acc update host(err,iter)
//#pragma acc loop
			//  gang vector vector_length()
//#pragma acc kernels
//����������� �������
/*#pragma acc loop
			{
			for(int i=0; i<s*s; i++)
			{
				arr[i]=setka[i];
//#pragma acc atomic update
//#pragma acc update device(arr[i])
//#pragma acc update host(arr[i])
#pragma acc update self(arr[i])
			}
			}*/
//#pragma acc kernels
//#pragma acc parallel loop gang num_gangs(4) vector vector_length(32)
//#pragma acc parallel loop reduction(max:err)
// loop gang vector(s*s)
//#pragma acc loop gang worker vector
//#pragma acc loop independent reduction(+:arr)
//#pragma acc loop gang vector collapse(2)
//#pragma acc loop gang
//{
//#pragma acc loop independent reduction(max:err)
//#pragma acc parallel loop reduction(max:err)
//#pragma acc parallel loop vector_length(32)/
//#pragma acc parallel loop num_workers(4) vector_length(32)
//#pragma acc parallel loop num_gangs(64)
// num_workers(128) vector_length(128)
//#pragma acc parallel loop gang worker num_workers(4) vector_length(128)
//#pragma acc parallel loop
//#pragma acc routine(setka) seq
#pragma acc data present(arr, setka)
#pragma acc parallel loop independent collapse(2) vector vector_length(256) gang num_gangs(256) reduction(max:err) 
			for(int i=1; i<s-1; i++)
			{
//#pragma acc loop reduction(max:err)
//#pragma acc parallel loop
//#pragma acc loop vector
//�������� ������ �������� max
//#pragma acc loop vector reduction(max:err)
				for(int j=1; j<s-1; j++)
				{
//					setka[IDX2C(i,j,s)]+=0.25*arr[IDX2C(i,j-1,s)];
//					setka[IDX2C(i,j,s)]+=0.25*arr[IDX2C(i,j+1,s)];
//					setka[IDX2C(i,j,s)]+=0.25*arr[IDX2C(i-1,j,s)];
//					setka[IDX2C(i,j,s)]+=0.25*arr[IDX2C(i+1,j,s)];
//					setka[i+j*(s-1)]=0.25*(arr[i+1+j*(s-1)]+arr[i-1+j*(s-1)]+arr[i+(j-1)*(s-1)]+arr[i+(j+1)*(s-1)]);
// host(setka[i+j*(s-1)])
//#pragma acc update host(setka[i+j*s])
//#pragma acc atomic write
//#pragma acc routine gang
					arr[IDX2C(i,j,s)]=0.25*(setka[IDX2C(i,j-1,s)]+setka[IDX2C(i,j+1,s)]+setka[IDX2C(i-1,j,s)]+setka[IDX2C(i+1,j,s)]);
//#pragma acc wait
//#pragma acc kernels
//{
//#pragma acc update host(err)
//#pragma acc atomic update
//#pragma acc wait
					err=fmax(err,fabs(arr[IDX2C(i,j,s)]-setka[IDX2C(i,j,s)]));
//}
//���������� ������
//#pragma acc update device(err)
				}
			}
			float* dop;
			dop = arr;
			arr=setka;
			setka = dop;
//}
			if(iter%100==0 || iter==1)
			{
			#pragma acc update host(err) 
//			#pragma acc wait(1)
				printf("%d %f \n",iter, err);
			}
			#pragma acc kernels
{
				printf("%f \n", err);
			for(int i=0; i<s; i++)
			{
				for(int j=0; j<s; j++)
					printf("%f ",arr[i+s*j]);
				printf("\n");
			}
}
		}
		printf("Count iterations: %d\nError: %.10f\n", iter,err);
//�������� ������ � GPU
}//#pragma acc exit data delete(arr[:s*s]) delete (setka[:s*s])
		if(s<20)
			for(int i=0; i<s; i++)
			{
				for(int j=0; j<s; j++)
					printf("%f ",setka[i+s*j]);
				printf("\n");
			}
		free(arr);
		free(setka);
	}
	return 0;
}

